EOL        equ 00           ; символ конца строки
BUFFER_LEN equ 256          ; размер буфера для вывода

global myPrintfC           

section .bss

buffer      resb BUFFER_LEN ; резервируем буфер для вывода

section .data

hexTable    db '0123456789ABCDEF' 

section .text

;-------------------------------------------------------------------------------
; обертка для вызова myPrintf с передачей аргументов через регистры
;-------------------------------------------------------------------------------

myPrintfC:    
            pop r10                 ; сохраняем возвратный адрес в r10

            push r9                 ; сохраняем аргументы в стеке
            push r8                 ; (rdi, rsi, rdx, rcx, r8, r9)
            push rcx                ; для совместимости с cdecl
            push rdx                ;
            push rsi                ;
            push rdi                ;

            push r10                ; возвращаем адрес возврата в стек

            push rbp                
            mov rbp, rsp            ; устанавливаем фрейм стека

            call myPrintf           

            pop rbp                 ; восстанавливаем rbp

            pop r10                 ; восстанавливаем адрес возврата

            add rsp, 6 * 8          ; очищаем стек 

            push r10                ; возвращаем адрес возврата в стек

            ret                     ; возвращаем управление вызывающей функции

;-------------------------------------------------------------------------------
; основная функция printf
;-------------------------------------------------------------------------------

myPrintf:
            mov rsi, [rbp + 16]     ; загружаем строку формата - первый аргумент

            mov rdi, buffer         ; указатель на буффер

            mov rbx, 0              ; счетчик аргументов, начиная с 0

.mainLoop:
            xor rax, rax            ; очищаем rax

            lodsb                   ; загружаем следующий символ из строки формата

            cmp al, EOL              
            je .end                 ; if al = EOL -> end

            cmp al, '%'             
            je .handleFormat        ; if al = % -> handleFormat

            mov [rdi], al           ; копируем символ в буфер
            inc rdi                 ; перемещаем указатель буфера

            jmp .mainLoop           ; переходим к следующему символу

.handleFormat:
            xor rax, rax            ; clean rax

            lodsb                   ; загружаем следующий символ 

            cmp al, '%'             
            je .printPercent        ; if al = % -> print %

            cmp al, 'x'             
            ja .invalidFormat       ; if al > x -> invalidFormat

            cmp al, 'b'             
            jb .invalidFormat       ; if al < b -> invalidFormat

            sub al, 'b'             ; вычисляем индекс в таблице переходов

            mov rax, [.formatJumpTable + rax * 8]
            jmp rax                 ; переходим к обработчику спецификатора

;-------------------------------------------------------------------------------
; таблица переходов для обработки спецификаторов формата
;-------------------------------------------------------------------------------

.formatJumpTable:
            dq .handleBinary                      ; case 'b'
            dq .handleChar                        ; case 'c'
            dq .handleDecimal                     ; case 'd'

            times ('n' - 'd') dq .invalidFormat   ; пропускаем неиспользуемые символы

            dq .handleOctal                       ; case 'o'

            times ('r' - 'o') dq .invalidFormat   ; пропускаем неиспользуемые символы

            dq .handleString                      ; case 's'

            times ('w' - 's') dq .invalidFormat   ; пропускаем неиспользуемые символы

            dq .handleHex                         ; case 'x'

;-------------------------------------------------------------------------------
; обработка спецификатора '%c' (символ)
;-------------------------------------------------------------------------------

.handleChar:
            inc rbx                               
            mov al, [rbp + 16 + 8 * rbx]          ; загружаем символ из аргумента

            stosb                                 ; сохраняем символ в буфер

            jmp .mainLoop                         ; возвращаемся к основному циклу

;-------------------------------------------------------------------------------
; обработка спецификатора '%s' (строка)
;-------------------------------------------------------------------------------

.handleString:
            push rsi                              ; сохраняем rsi (указатель на строку формата)
            inc rbx                 

            mov rsi, [rbp + 16 + 8 * rbx]         ; загружаем указатель на строку из аргумента

.copyStringLoop:
            movsb                                 ; копируем символ из строки в буфер

            cmp BYTE [rsi], EOL                   
            jne .copyStringLoop                   ; if [rsi] != EOL -> copyStringLoop

            pop rsi                               ; восстанавливаем rsi
            
            jmp .mainLoop                         ; возвращаемся к основному циклу

;-------------------------------------------------------------------------------
; обработка спецификатора '%d' (десятичное число)
;-------------------------------------------------------------------------------

.handleDecimal:
            mov cl, 0               
            jmp .printNumber        

;-------------------------------------------------------------------------------
; обработка спецификатора '%b' (двоичное число)
;-------------------------------------------------------------------------------

.handleBinary:
            mov cl, 1               
            jmp .printNumber        

;-------------------------------------------------------------------------------
; обработка спецификатора '%o' (восьмеричное число)
;-------------------------------------------------------------------------------

.handleOctal:
            mov cl, 3               
            jmp .printNumber        

;-------------------------------------------------------------------------------
; обработка спецификатора '%x' (шестнадцатеричное число)
;-------------------------------------------------------------------------------

.handleHex:
            mov cl, 4               
            jmp .printNumber        

;-------------------------------------------------------------------------------
; общая функция для вывода чисел
;-------------------------------------------------------------------------------

.printNumber:
            inc rbx                               
            mov rdx, [rbp + 16 + 8 * rbx]         ; загружаем число из аргумента

            mov r8, 01b                           
            shl r8, cl                            
            dec r8                  

.checkNegative:
            test rdx, rdx                         ; проверяем, отрицательное ли число
            jns .convertNumber                    ; if unsigned -> convertNumber

            mov al, 0x2D                          ; добавляем '-' в буфер
            stosb                   

            neg rdx                               ; преобразуем число в положительное

.convertNumber:
            mov rax, r8                          
            and rax, rdx                          

            shr rdx, cl                           ; сдвигаем число для обработки следующих битов

            mov al, [hexTable + rax]              ; преобразуем число в символ
            stosb                                 ; сохраняем символ в буфер

            cmp rdx, 0                            ; проверяем, не закончилось ли число
            jne .convertNumber      

            jmp .mainLoop                         ; возвращаемся к основному циклу

;-------------------------------------------------------------------------------
; обработка неверного спецификатора
;-------------------------------------------------------------------------------

.invalidFormat:
            mov byte [rdi], '%'                   ; выводим '%' как есть
            inc rdi

            jmp .mainLoop                         ; возвращаемся к основному циклу

;-------------------------------------------------------------------------------
; обработка спецификатора '%%' (символ '%')
;-------------------------------------------------------------------------------

.printPercent:
            stosb                                 ; выводим '%'
            jmp .mainLoop                         

;-------------------------------------------------------------------------------
; завершение функции
;-------------------------------------------------------------------------------

.end:
            mov al, 0xa             ; добавляем символ новой строки '\n'
            mov [rdi], al

            sub rdi, buffer - 1     ; вычисляем длину вывода
            mov rdx, rdi            ; сохраняем длину в rdx

            mov rax, 0x01           ; системный вызов write (1 - stdout)
            mov rdi, 1
            mov rsi, buffer
            syscall

            xor rax, rax            ; возвращаем 0
            ret

section .note.GNU-stack noalloc noexec nowrite progbits